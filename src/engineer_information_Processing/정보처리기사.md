
# 1과목 소프트웨어 설계

[소프트웨어 생명 주기]

- 소프트웨어를 개발하기 위한 과정 (요구사항 분석, 설계, 개발, 유지보수 등)

- 폭포수 모형, 프로토타입 모형, 나선형 모형, 애자일



(1) 폭포수 모형

- 이전 단계로 돌아갈 수 없고 앞단계가 끝나야 다음단계로 넘어간다.



(2) 프로토타입 모형

- 프로토타입을 만들어 최종 결과물을 예측한다.

- 새로운 요구사항이 도출될 때마다 프로토타입 구축한다.

- 새로운 요구사항 반영 가능



(3) 나선형 모형 (점진형 모형)

- 여러 번의 소프트웨어 개발과정의 반복 (계획 -> 분석 -> 개발 -> 평가)

- 위험 관리 중심, 요구사항 반영 가능, 유지보수 필요 없음



(4) 애자일

- 고객과의 소통에 초점을 맞춘 개발 방법론

- 스프린트 또는 이터레이션 같은 짧은 개발 주기를 반복(테스트 주도 개발)

- 종류 : 스크럼, XP, 기능 중심 개발(FDD)

- [XP 기법]

a. 이터레이션(짧은 개발-피드백 단위) 반복

b. 핵심가치 : 피드백, 존중, 용기, 단순성, 소통

c. 주요 실천 방법 : 페어 프로그래밍, 코드 공동 소유, 테스트 주도 개발





[요구사항 분석]



1. 요구사항

정의 : 소프트웨어에 대한 필요 조건이나 제약사항

- 기능 요구사항 : 소프트웨어가 반드시 수행해야 하는 기능

- 비기능 요구 사항 : 성능, 보안, 품질, 제약사항 등



2. 요구사항 분석 과정



(1) 도출 : 질문을 바탕으로 요구사항을 수집

(2) 분석 : 요구사항의 타당성 분석, 상충될 경우 중재

(3) 명세 : 문서화(명세서 작성)

(4) 확인 : 방법 - 동료검토 / 워크쓰루 (사전 검토 후 회의) / 인스펙션 (전문가 검토)



3. 요구사항 분석 시 이용되는 도구

a. UML

b. 자료 흐름도(DFD)

- Process : 동그라미로 표기

- Data Flow : 화살표로 표시

- Data Store : 평행선인 두줄로 표시

- Terminator : 사각형으로 표기



[작성지침]

- 자료 흐름은 처리를 거쳐 변환될 때마다 새로운 이름을 부여한다.

- 어떤 처리가 출력 자료를 산출하기 위해서는 반드시 입력 자료가 발생해야 한다.

- 상위 단계의 처리와 하위 자료 흐름도의 자료 흐름은 서로 일치되어야 한다.

- 입력 화살표가 있다고 하여 반드시 출력 화살표가 있어야 하는 것은 아니다



c. 자료 사전(DD)



=

자료의 정의

+

자료의 연결

( )

자료의 생략

[ | ]

자료의 선택

{ }

자료의 반복

**

자료의 설명(주석)





HIPO

- 시스템의 분석 및 설계나 문서화할 때 사용되는 기법

- 입력, 처리, 출력으로 구성되며 하향식 소프트웨어 개발을 위한 문서화 도구

- 기호, 도표 등을 사용해 보기 쉽고 이해하기 쉬움

- 기능과 자료의 의존 관계 동시에 표현 가능



HIPO Chart 종류

a. 가시적 도표

b. 총체적 도표

c. 세부적 도표





[UML]



- 개발 과정에서 의사 소통이 원활하게 이뤄지도록 표준화한 객체 지향 모델링 언어

- 구성 요소 : 사물, 관계, 다이어그램



1. 사물

- 구조(Structural Things)

- 행동(Behavioral Things)

- 그룹(Grouping Things)

- 주해(Annotation Things)



2. 관계





3. 다이어그램

(구조적 다이어그램)



a. 클래스 다이어그램

b. 객체 다이어그램

c. 컴포넌트 다이어그램,

d. 배치 다이어그램

e. 복합체 구조 다이어그램

f. 패키지 다이어그램



(행위 다이어그램)

a. 유스케이스 다이어그램

b. 순차 다이어그램

c. 커뮤니케이션 다이어그램

d. 상태 다이어그램

- 객체들 사이에서 발생하는 이벤트에 의한 객체들의 상태 변화를 그림으로 표현

- 럼바우(RUmbaugh) 객체지향 분석 기법에서 동적 모델링에 활용한다.



e. 활동 다이어그램

- 오퍼레이션이나 처리 과정이 수행되는 동안 일어나는 일들을 단계적으로 표현

f. 상호작용 개요 다이어그램

h. 타이밍 다이어그램









[주요 UML 다이어그램]



1. 유스케이스 다이어그램

- 사용자와 다른 외부 시스템들이 개발될 시스템을 이용해 수행할 수 있는 기능을 사용자 관점에서 표현한 것



(구성요소)

- 시스템 / 시스템 범위 : 내부, 외부 시스템을 구분하기 위해 시스템 내부의 유스케이스들을 사각형으로 묶어 시스템의 범위 표현

- 액터 : 시스템과 상호작용하는 모든 외부 요소

- 유스케이스 : 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스 또는 기능

- 관계 : 구성요소들간의 관계





2. 클래스 다이어그램

- 정의 : 시스템을 구성하는 클래스, 클래스의 특성과 오퍼레이션(동작), 속성과 오퍼레이션에 대한 제약조건, 클래스 사이의 관계를 나타냄

- 구성요소 : 클래스, 제약조건, 관계



3. 순차 다이어그램

- 정의 : 시스템이나 객체들이 시간의 흐름에 따라 상호작용하는 과정을 표현 

[사용자 인터페이스]
- 사용자와 시스템 간의 상호작용이 원활하게 이뤄지도록 도와주는 장치 또는 소프트웨어

1. 특징
- 편리성과 가독을 높이고 작업 시간을 단축시키며 업무에 대한 이해도 높임
- 사용자 중심으로 설계하여 사용자 중심의 상호 작용
- 수행 결과의 오류 줄임
- UI 를 설계하기 위해서는 소프트웨어 아키텍처 반드시 숙지

2. 사용자 인터페이스의 구분
- CLI : 텍스트 형태로 이뤄지는 인터페이스
- GUI : 아이콘이나 메뉴를 마우스로 작업하는 그래픽 환경의 인터페이스
- NUI : 말이나 행동으로 기기를 조작하는 인터페이스
- VUI : 사람의 음성으로 기기를 조작하는 인터페이스
- OUI : 사물인터넷, 증강현실 등에서 모든 사물과 사용자 간의 상호작용 위한 인터페이스

3. 기본 원칙
- 직관성 : 누구나 쉽게 이해하고 사용
- 유효성 : 사용자의 목적을 정확하게 달성
- 학습성 : 누구나 쉽게 배우고 익혀야 함
- 유연성 : 사용자의 요구사항을 최대한 수용하고 실수 최소화

4. 설계 지침
- 사용자 중심, 사용성, 심미성, 오류 발생 해결(사용자가 오류를 쉽게 인지) 등

  [소프트웨어 아키텍처]

1. 상위 설계와 하위 설계
   a. 상위 설계(아키텍처 설계, 예비 설계)
   - 시스템의 전체적인 구조(구조, DB, 인터페이스)
   b. 하위 설계(모듈 설계, 상세 설계)
   - 시스템의 내부 구조 및 행위(컴포넌트, 자료구조, 알고리즘)
   
2. 모듈화
- 소프트웨어 성능 향상, 시스템 수정 및 재사용, 유지관리 등이 용이하도록 시스템의
  기능을 모듈 단위로 나누는 것
- 자주 사용되는 기능들은 공통 모듈로 구성하여 재사용성 향상시킬 수 있음
- 모듈의 크기 너무 작게 나누면 개수가 많아져 비용이 많이 들고 크게 나누면 모듈
  하나의 비용이 증가
- 모듈화를 통해 인터페이스 단순화 가능
- 모듈화를 통해 프로그램 효율적 관리, 오류 파급 효과 최소화 가능

3. 설계 과정
   설계 목표 설정 -> 시스템 타입 결정 -> 아키텍처패턴 적용 -> 서브시스템 구체화 -> 검토

[아키텍처 패턴]

1. 파이트 - 필터 패턴
- 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 필터화 -> 파이프 통해 데이터
  전송
- 이전 시스템 결과를 파이프 통해 전달받아 처리한 후 결과물 파이프 통해 다음
  시스템으로 전달하는 구조
- 재사용성 및 확장 용이
- 재배치하여 다양한 파이프라인 구축 가능

[객체지향]

1. 객체
- 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화한) 하나의 소프트웨어 모듈
- 객체의 특성
  1. 객체는 독립적으로 식별 가능한 이름 가진다.
  2. 객체가 가질 수 있는 조건을 상태라고 하고 상태는 시간에 따라 변함
  3. 객체와 객체는 상호 연관성에 의한 관계가 형성된다
  4. 객체가 반응할 수 있는 메시지 집합을 행위라고 하며 객체는 행위의 특징을 나타낸다.

2. 클래스
- 공통된 속성과 연산을 갖는 객체의 집합

3. 객체지향의 특징
- 캡슐화 : 데이터와 데이터를 처리하는 함수를 하나로 묶는 것을 의미
- 상속 : 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려 받는 것
- 다형성 : 메시지에 의해 객체가 연산을 수행할 때 하나의 메시지에 대해 각각의
  객체가 가지고 있는 고유한 특성으로 응답할 수 있는 능력
- 연관성 : 두 개 이상의 객체들이 상호 참조하는 관계


[객체지향 분석의 개념]

방법론
1. Rumbaugh(럼바우) 기법
- 가장 일반적으로 사용되는 방법으로 객체 모델링 기법이라고도 한다.
- 분석 활동은 객체 모델링 -> 동적 모델링 -> 기능 모델링 순으로 통해 이루어진다.
  a. 객체 모델링 : 객체와 객체간의 관계를 찾아내 객체 다이어그램로 표시
  b. 동적 모델링 : 상태 다이어그램을 이용해 객체들 간의 동적인 행위를 표현
  c. 기능 모델링 : 자료 흐름도(DFD)를 이용하여 프로세스 간의 자료 흐름을 표현
2. Booch 방법
3. Jacabson 방법
4. Coad & Yourdon 방법 : ER 다이어그램 사용하여 객체의 행위 모델링
5. Wirfs-Brocka 방법

객체지향 설계 원칙
1. SRP (단일 책임 원칙) : 객체는 단 하나의 책임만, 응집도는 높고 결합도는 낮게
2. OCP (개방 - 폐쇄 원칙) : 기존 코드 변경 않고 새로운 기능 추가 가능해야 한다.
3. LSP (리스코프 치환 원칙) : 자식 클래스는 최소한 부모 클래스에서 가능한 행위는 수행
   가능해야 한다.
4. ISP (인터페이스 분리 원칙) : 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나
   영향 받지 않아야 한다.)
5. DIP (의존 역전 원칙) : 객체들 간 의존 관계 성립될 때 추상성이 높은 클래스와 의존 관계를 맺어야 한다.

[모듈]

1.결합도(Coupling)

- 결합도가 약할수록 품질 높고 강할수록 시스템 구현 및 유지보수가 어려워 품질이
  낮다.

결합도 강도
자료 결합도 < 스탬프 결합도 < 제어 결합도 < 외부 결합도 < 공통 결합도 < 내용 결합도
  (Data) (Stamp) (Control) (External) (Common) (Content)
2. 응집도(Cohesion)
- 정보 은닉 개념을 확장한 것으로 모듈이 독립적인 기능으로 정의되어 있는 정도
  나타냄
- 응집도가 강할수록 품질이 높다.
  
응집도 강도
우연적 응집 < 논리적 응집 < 시간적 응집 < 절차적 응집 < 교환적 응집 < 순차적 응집
  (Coincidental) (Logical) (Temporal) (Procedural) (Communication) (Sequential)

3. 팬인 / 팬아웃
- 모듈에 들어오면 팬인, 나오면 팬아웃
- 팬인이 높다는 것은 재사용 측면에서 설계가 잘되어 있음. 단일 장애점 발생 유의
- 팬아웃이 높은 경우 불필요하게 다른 모듈 호출하는지 확인 후 단순화 가능한지 확인

[디자인 패턴]

생성패턴
- 추상 팩토리 패턴 : 인터페이스를 조합해 객체 생성
- 빌더 패턴 : 다른 객체 조합하여 객체 생성
- 팩토리 메소드 패턴 : 상위 클래스를 바탕으로 하위 클래스에서 구체화
- 프로토타입 패턴 : 원본 객체를 복사해서 생성
- 싱글톤 패턴 : 클래스 내에서 인스턴스 하나뿐임을 보장

구조 패턴
- 어탭터 패턴 : 호환되지 않는 클래스를 다른 클래스가 이용할 수 있도록 변환
- 브릿지 패턴 : 기능과 구현을 두 개의 별도 클래스로 구현
- 컴포지트 : 객체들을 트리 구조로 구성
- 프록시 : 접근이 어려운 객체 사이의 인터페이스 역할 수행
- 기타 : 데코레이터, 퍼싸드, 플라이웨이트 등

행위 패턴
- 커맨드 패턴 : 요청을 캡슐화해서 저장
- 중재자 패턴 : 상호작용을 캡슐화하여 객체로 정의
- 옵저버 패턴 : 한 객체의 상태가 변환하면 다른 객체들에게 전달
- 상태 패턴 : 상태에 따라 다르게 처리
- 전략 패턴 : 동일 계열 알고리즘을 개별적 캡슐화
- 템플릿 메소드 패턴 : 상위 클래스는 골격 정의, 하위 클래스는 세부 처리
- 방문자 패턴 : 처리 기능을 분리하여 별도의 클래스로 구성

[미들웨어 솔루션 명세]

미들웨어
- 운영체제와 응용 프로그램 또는 서버와 클라이언트 사이에서 원만한 토잇ㄴ이
  이루어지도록 다양한 서비스 제공

종류
1. DB
2. RPC (Remote Procedure Call)
3. MOM (Message Oriented Middleware)
- 온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위하여 사용
- 서로 다른 플랫폼에서 독립적으로 실행되는 소프트웨어 간 상호 작용을 통해 하나의
  통합된 시스템처럼 동작되도록 함
4. TP-Monitor (Transaction Processing Monitor)
5. ORB ( Object Request Broker)
6. WAS ( Web Application Server)

[자료 구조]
(1) 선형 자료 구조
: 배열, 선형 리스트(연속리스트와 연결리스트), 스택, 큐, 데크

a. 스택
- 특징 : 한 쪽으로만 입출력 => 후입선출 (LIFO, Last In First Out)
- 오버플로우 : 스택이 가득 찬 상태에서 데이터 삽입시 발생
- 언더플로우 :스택이 텅 빈 상태에서 데이터 삭제시 발생
- 활용 : 인터럽트의 처리. 수식의 계산, 서브루틴 호출 작업 등

b. 큐
: 선입선출 (FIFO, First In First Out)

c. 데크
: 삽입과 삭제가 양쪽 끝에서 모두 발생 가능

(2) 비선형 자료 구조
: 트리, 그래프

a. 트리
- 정의 : 사이클이 없는 그래프

[구성요소]
- 노드(정점) : 트리의 기본 요소 (하나의 기억 공간)
- 링크(간선) : 노드와 노드를 연결하는 선
- 차수(Degree) : 연결된 자식 노드의 개수 = 각 노드가 가진 가지수
- 트리의 차수 : 노드의 차수 중 가장 많은 수
- 루트 노드 : 맨 위에 있는 노드
- 리프 노드 : 차수가 0 인 노드

트리의 운행법(순회 방법) 순회 순서
Preorder (전위)
: root -> left -> right | ABDCEFG

Inorder (중위)
: left -> root -> right | DBAECFG

Postorder (후위)
: left -> right -> root | DBEGFCA

[디지털 저작권 관리 (DRM)]
디지털 저작권 관리의 기술 요소
- 암호화
- 키 관리
- 암호화 파일 생성
- 식별 기술
- 저작권 표현
- 정책 관리
- 크랙 방지
- 인증

[소프트웨어 버전 등록]

소프트웨어 패키징의 형상 관리
- 소프트웨어의 개발 과정에서 변경 사항을 관리하기 위해 개발된 일련의 활동
- 변경의 원인을 알아내고 제어하며 적절히 변경되고 있는지 확인
- 소프트웨어 개발 전 단계에 적용되는 활동이며 유지보수 단계에서도 수행
- 개발 전체 비용 줄이고 여러 방해 요인이 최소화되도록 보장
- 가시성과 추적성 보장함으로 생산성과 품질 높임
- Ex) Git, CVS, Subversion 등
- 
소프트웨어 버전 등록 관련 주요 기능
- 저장소
- 가져오기
- 체크아웃
: 프로그램을 수정하기 위해 저장소에서 파일 받아옴
- 체크인
: 수정한 프로그램을 저장소의 파일을 새로운 버전으로 갱신
- 커밋
: 체크인 과정에서 이전에 갱신된 내용이 있는 경우 충돌 알리고 diff 도구를 이용해 해결
- 동기화

[테스트 기법에 따른 애플리케이션 테스트]

화이트박스 테스트
- 모듈의 원시 코드를 오픈시킨 상태에서 코드의 논리적은 모든 경로를 테스트하여
테스트 케이스를 설계하는 방법 (테스트 과정 초기의 적용)

화이트박스 테스트의 종류
- 기초 경로 검사
: 대표적인 화이트박스 테스트 기법
테스트케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 기법

블랙박스 테스트
- 스프트웨어가 수행할 특정 기능을 알기 위해서 각 기능이 완전히 작동되는 것을
입증하는 기능 테스트 (테스트 과정의 후반부에 적용)

블랙박스 테스트 종류
- 동치 분할 검사 테스트
: 입력 조건에 타당한 입력 자료와 타당하지 않은 자료의 개수를 균등하게 하여
- 경계값 분석
- 원인-효과 그래프 검사

[복잡도]
빅오 표기법
- 알고리즘 실행시간이 최악일 때 표기하는 방법으로 성능을 예측하기 용이하여 주로
사용
- O(1)
: 입력값에 관계 없이 일정하게 문제 해결에 하나의 단계만 거침 [스택의 삽입]
- O(log2 𝑛)
: 문제 해결에 필요한 단계가 입력값 또는 조건에 의해 감소 [이진 트리, 이진 검색]
- O(n)
: 문제 해결에 필요한 단계가 입력값과 1:1 관계를 가짐 [for 문]
- O(nlog2 𝑛)
: 문제 해결에 필요한 단계가 nlog2 𝑛 만큼 수행된다. [힙 정렬]
- O(n^2)
: 문제 해결에 필요한 단계가 입력값의 제곱만큼 수행된다 [삽입, 선택, 버블, 퀵 정렬]
- O(2^n)
: 문제 해결에 필요한 단계가 2 의 입력값 제곱만큼 수행된다 [피보나치 수열]
  
[소스 코드 최적화]
나쁜 코드
- 스파게티 코드 : 코드의 로직이 서로 복잡하게 얽혀 있는 코드
- 외계인 코드 : 아주 오래되거나 참고문서 또는 개발자가 없어 유지 보수가 어려운
코드
클린 코드의 작성 원칙
- 가독성
- 단순성
- 의존성 배제
: 코드가 다른 모듈에 미치는 영향을 최소화, 코드 변경 시 다른 부분에 영향 X
- 중복성 최소화
- 추상화
: 상위 클래스/함수/메서드에선 간략히 특성을 나타내고 하위 클래스/함수/메서드에서 구현

 

 

 
 