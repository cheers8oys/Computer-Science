
# 서버란 무엇인가?

- 한 컴퓨터가 네트워크로 연결된 하나 또는 그 이상의 컴퓨터들에게 무언가를 해주면 '서버'가 된다.
- 그리고 무언가를 받는 컴퓨터는 '클라이언트'이다.

# AWS? 클라우드 컴퓨팅이 무엇인가요?

- Amazon의 AWS, Google의 GCP, Microsoft의 Azure 등이 있다.
- 온프레미스 방식 : 회사가 자사의 시설 혹은 IDC 자체적으로 서버를 두고 운영하는 방식

- 클라우드 컴퓨팅 시스템 :
클라우드 컴퓨팅은 인터넷을 통해 서버, 스토리지, 데이터베이스, 네트워크, 소프트웨어 등 IT 자원을 필요할 때마다 빌려 쓰는 서비스
필요한 만큼만 자원을 빌려 쓰고 사용량에 따라 비용을 지불하는 방식 클라우드는 대형 데이터센터에 수많은 컴퓨터가 연결되어 있고, 
사용자는 이 중 필요한 만큼의 자원을 가상화 기술로 나누어 사용합니다.

클라우드 서비스의 종류
1. IaaS (Infrastructure as a Service)	
가상 컴퓨터, 스토리지 등 인프라만 제공 | 사용자가 직접 운영체제, 소프트웨어 설치·관리	| AWS EC2, 네이버 클라우드 서버
2. PaaS (Platform as a Service)	
인프라 + 운영체제, 미들웨어 등 플랫폼까지 제공 | 사용자는 코드만 올리면 됨 | AWS Elastic Beanstalk, Heroku
3. SaaS (Software as a Service)	
완성된 소프트웨어를 서비스로 제공 | 사용자는 바로 사용 | 구글 드라이브, 드롭박스, 에버노트

- 클라우드의 장점
1. 확장성: 필요할 때 자원을 쉽게 늘리거나 줄일 수 있음
2. 비용 효율성: 사용한 만큼만 비용을 지불
3. 관리 편의성: 하드웨어, 네트워크 등 인프라 관리를 클라우드 업체가 담당
4. 접근성: 인터넷만 있으면 어디서든 사용 가능

- 활용 예시
스타트업이나 중소기업은 초기 투자 없이 서비스를 빠르게 시작할 수 있습니다.
대기업은 글로벌 서비스 운영, 데이터 통합, 빠른 확장에 유리합니다.

# 가비지 컬렉터(GC)란 무엇인가요? (Feat. 메모리 관리)

프로그래밍 언어에서 더 이상 사용되지 않는 메모리(객체, 변수 등)를 자동으로 탐지하고 회수하는 메모리 관리 시스템
개발자가 직접 메모리 해제 코드를 작성하지 않아도 프로그램이 동적으로 할당한 메모리 중 필요 없어진 부분을 자동으로 정리

managed language(가비지 콜렉터 존재하는 프로그래밍 언어) : Java, C#, Python 등 
unmanaged language : C, C++ 등

** 가비지 콜렉터가 존재하는 언어를 쓴다고 메모리 누수를 아예 신경쓰지 않아도 되는 것은 아님.
쓰는 언어나 플랫폼, 기기마다의 바람직한 메모리 관리 방식을 이것저것 알아볼 필요 있음
ex) 순참참조 금지

# try? catch? 예외처리란 무엇인가요?

예외 처리는 프로그래머가 코드로 제어할 수 없는 돌발 상황(오류, 에러 등)에 안전하게 대응하기 위한 장치
컴퓨터 프로그램은 융통성이 없어 오류가 발생하면 프로세스가 바로 종료될 수 있어 이를 방지하기 위해 예외 처리 구문을 사용

예외 처리는 주로 런타임 오류나 프로그래머의 논리 오류와 같이 예측하기 어려운 상황에 대응하기 위해 사용

## 예외 처리의 장점과 주의점
- 장점
1. 프로그램이 예기치 않은 상황에서도 안전하게 동작을 이어갈 수 있음
2. 코드의 안정성과 신뢰성을 높여줌.
3. 자원(파일, 네트워크 등) 해제와 같은 후처리를 확실하게 할 수 있음.

- 주의점
1. 예외 처리를 남용하면 오류의 원인을 제대로 파악하지 못하고 문제를 덮어버릴 수 있음.

- 실무에서의 활용 팁
1. 오류가 발생할 수 있는 부분만 최소한으로 try로 감싸는 것이 좋음
2. finally(또는 ensure) 구문을 활용해 자원 해제, 정리 작업을 반드시 수행
3. 예외 처리에만 의존하지 말고, 오류의 원인을 분석하고 예방하는 습관을 들이기

# CI/CD란 무엇인가?

- 어플리케이션 개발 단계부터 배포까지 모든 단계들을 자동화를 통해 효율적으로 빠르게 사용자에게 빈번하게 배포할 수 있게 만드는 것
- CI(Continuous Integration) : 지속적인 통합
    - 버그 수정이나 새로운 기능 추가 등이 메인 리포지토리에 빌드되고 테스트 되어 머지되는 것을 말함.
    1. 코드 변경사항을 주기적으로 빈번하게 최대한 작은 단위로 머지해야 한다.
    2. 통합을 위한 단계(빌드, 테스트, 머지)의 자동화
        - 문제점을 빠르게 발견하여 버그 수정이 용이 -> 코드의 퀄리티 향상
    
- CD(Continuous Delivery or Continuous Deployment) : 지속적인 제공
    - Continuous Deliver : 최종 배포는 개발자가 최종 검수하여 배포
    - Continuous Deployment : CI단계가 성공적으로 마무리된다면 배포까지 자동화

- CI/CD의 대표적인 툴 : Jenkins, Buildkite, Github Actions, GitLab CI/CD, Bitbucket Pipelines 등

# 정적웹 vs 동적웹

- 정적웹 : 언제 접속해도 같은 리소스를 보여주는 웹사이트 (ex. 웹사이트 소개글, 댓글 기능이 없는 블로그 페이지 등)
- 동적웹 : 접속할 때마다 서버가 그때그때 데이터를 가공해 새로운 웹페이지를 만들어 제공 (ex. SNS 댓글처럼 정보가 계속해서 변화하는 사이트 등)


# 재귀 함수가 무엇인가?
- 함수가 자기 자신을 직접 또는 간접적으로 호출하는 함수
- 반복문 없이도 반복적인 작업을 수행할 수 있게 해주며, 복잡한 문제를 더 작고 단순한 문제로 나누어 해결하는 데 유용

- 재귀함수의 위험성
1. 스택 오버플로우: 재귀 호출이 너무 깊어지면 메모리(스택)가 부족해 오류 발생
2. 성능 저하: 불필요한 중복 호출이 많으면 비효율적(예: 피보나치 수열의 단순 재귀 구현)
3. 디버깅 어려움: 호출 흐름이 복잡해 코드 이해와 디버깅이 어려움

# 개발시 데이터베이스 선택 가이드

1. Key - Value Database 
- 보통 보조 DB로 많이 사용. 데이터를 HDD에 저장하지 않고 RAM에 저장 (ex. Redis)
- 메인 DB에서 사용자들이 많이 사용하는 데이터는 Redis에도 저장해서 요청시 Redis에서 전송하는 식으로 많이 사용
- 자주쓰는 데이터 캐싱, 채팅을 위한 pub/sub, 영상 스트리밍, 로그인기록저장 등

2. Relational Database
- 데이터 입출력 속도보다 정확도가 중요한 서비스라면 RDS 사용 (ex. Mysql, Oracle, MariaDB, SQLite, PostgreSQL 등)
- 특별한 경우를 제외하고 대부분의 경우 RDS 사용하면 됨

3. Graph Database
- 데이터끼리의 관계를 잘 나타내고 싶을 때 사용 (ex. neo4j)
- 노드라는 걸 만들고 노드 안에 데이터를 저장하고 노드끼리 어떤 관계인지 기록할 수 있음.
- Graph Query 사용
- 비행기 노선, 코로나 감염 경로, SNS 친구 관계, 추천서비스 등

4. Document Database (ex. mongoDB 등)
- JSON 형태로 저장. 
- 관계형 데이터베이스와 다르게 미리 어떤 걸 저장할지 정하지 않아도 되고 구조 바뀌어도 오류X
- 중복데이터 제거 하지 않으므로 정규화 X
- 대부분 분산처리 잘해주므로 데이터 입출력이 잦은 경우 사용하기 좋음. But, 일관성 떨어질 수 있음

5. Search Engine (ex. Elastic Search, Amazon CloudSearch 등)
- index 보관용으로 특화
- 실시간 검색어, 추천 검색어, 검색어 오타교정 등 검색이 중요한 서비스에 많이 사용


# MVC 웹프레임워크가 뭔가요?
웹 애플리케이션을 Model, View, Controller로 분리하여 유지보수성과 확장성을 높여주는 개발 도구

- MVC의 기본 개념

Model : 데이터와 데이터의 형식, 저장, 불러오기 등 데이터 관련 로직을 담당
View : 사용자가 실제로 보는 화면, HTML, CSS 등 시각적 요소를 담당
Controller : 사용자의 요청을 받아 모델과 뷰를 연결하고 전체 흐름을 제어하는 담당

- MVC 구조의 필요성
단순한 동적 웹은 모든 기능이 한 파일에 섞여 있어 규모가 커지면 유지보수가 어려움
MVC 구조를 사용하면 각 역할별로 코드를 분리해, 복잡한 웹사이트도 효율적으로 개발할 수 있음


# AWS EC2, RDS, S3, Elastic Beanstalk

1. AWS EC2
- Elastic Compute Cloud의 약자로 클라우드 컴퓨팅 서비스의 일종으로 인터넷을 통해 서버를 빌려 원격으로 사용하는 서비스

## 장점
1. 비용 효율성: 필요한 만큼만 사용하고, 사용한 만큼만 비용을 지불합니다.
2. 유연성: 서비스 규모에 따라 자원을 쉽게 확장하거나 축소할 수 있습니다.
3. 시간 절약: 고성능 컴퓨터를 짧은 시간만 빌려서 빠르게 작업을 끝낼 수 있습니다.


2. AWS S3
- Simple Storage Service의 약자로 아마존 웹 서비스(AWS)에서 제공하는 대표적인 객체(오브젝트) 스토리지 서비스
- 사진, 동영상, 문서, 백업 데이터 등 다양한 파일을 인터넷을 통해 안전하게 저장하고 언제 어디서나 꺼내 쓸 수 있음
- 사용자가 원하는 만큼 데이터를 저장할 수 있으며, 자동으로 확장되고, 사용한 만큼만 비용을 지불하는 종량제 모델

## 주요특징
- 무한에 가까운 확장성, 고가용성 및 내구성, 강력한 보안, 유연한 관리, 글로벌 접근성

3. AWS CloudFront (Cache Server + CDN)
- 아마존 웹 서비스(AWS)가 제공하는 글로벌 콘텐츠 전송 네트워크(Content Delvery Network) 서비스
- 정적(HTML, CSS, JS, 이미지 등)과 동적(동영상, API 응답 등) 웹 콘텐츠를 전 세계 사용자에게 빠르고 안전하게 제공할 수 있도록 도와줌

## 장점
1. 빠른 콘텐츠 전송: 글로벌 엣지 네트워크로 지연 시간 최소화
2. 서버 부하 감소: 캐싱을 통해 오리진 서버의 요청 수 감소
3. 높은 가용성 및 안정성: 여러 위치에 파일이 복제되어 장애에도 안전
4. 보안 강화: DDoS 방어, SSL, WAF 등 다양한 보안 기능 제공
5. 비용 절감: 대역폭 및 서버 리소스 비용 절감 효과

## 동작원리
1. 사용자가 웹사이트나 앱에서 콘텐츠를 요청
2. DNS가 요청을 가장 가까운 CloudFront 엣지 로케이션으로 라우팅
3. 엣지 로케이션에 캐시된 파일이 있으면 즉시 전달, 없으면 오리진 서버에서 가져와 저장 후 전달
4. 이후 동일한 요청이 들어오면 엣지 로케이션에서 바로 제공되어 속도 향상

4. AWS RDS
- Amazon Web Services에서 제공하는 대표적인 관리형 관계형 데이터베이스 서비스
- MySQL, PostgreSQL, MariaDB, Oracle, SQL Server, Amazon Aurora 등 다양한 데이터베이스 엔진을 지원
- 사용자는 데이터베이스 설치, 운영, 백업, 패치, 확장 등 복잡한 관리 작업을 AWS에 맡기고, 애플리케이션 개발에 집중할 수 있음
- EC2에 직접 데이터베이스를 설치하는 것보다 비용이 더 높을 수 있지만 관리, 보안, 안정성, 인건비 등을 고려하면 오히려 경제적일 수 있음

## 주요 특징 및 장점
1. 완전 관리형 서비스: 하드웨어 프로비저닝, 데이터베이스 설치, 패치, 백업, 복구, 장애 조치 등 관리 작업을 AWS가 대신 처리합니다.
2. 고가용성 및 내구성: 여러 가용 영역(Availability Zone)에 데이터가 복제되어 장애 발생 시 자동으로 복구됩니다.
3. 자동 백업: 지정한 기간 동안 자동 백업 및 스냅샷 기능을 제공, 데이터 복구가 용이합니다.
4. 확장성: 콘솔 또는 API를 통해 몇 분 만에 용량(스토리지, CPU, 메모리 등)을 손쉽게 확장·축소할 수 있습니다.
5. 보안: 데이터 암호화, 네트워크 접근 제어, IAM(Identity and Access Management) 등 다양한 보안 기능을 제공합니다.
6. 비용 효율성: 사용한 만큼만 비용을 지불하는 종량제 모델로, 초기 투자 없이 데이터베이스를 운영할 수 있습니


# SQLite vs MySQL vs PostgreSQL

SQLite: 서버 관리가 필요 없고 소규모/임베디드/로컬 환경에서 빠르게 개발 필요시
MySQL: 웹서비스 등에서 널리 쓰이고 관리와 확장성이 균형 잡힌 솔루션이 필요시
PostgreSQL: 복잡한 비즈니스 로직, 데이터 분석, 고급 기능이 필요한 대규모 서비스에 적합

SQLite : 서버가 필요 없는 임베디드형 경량 데이터베이스로 기본 SQL 기능과 제한적인 데이터 타입을 제공하며 가볍고 이식성 높으며
관리 부담이 적은 장점을 가지고 있음. 소규모-저트래픽에 최적이며 동시성이 제한됨.

MySQL : 전통적인 서버 기반의 RDBMS로 웹 서비스, 스타트업, 중소규모 서비스에서 널리 사용되며 대규모 커뮤니티가 형성되어 있어 레퍼런스 많고
다양한 데이터 타입과 JSON, 다수 사용자 동시 접속 지원, 트랜잭션 성능 우수 등의 장점으로 인해 대부분의 웹서비스에서 표준처럼 사용

PostgreSQL : 고급 기능과 확장성을 갖춘 오픈소스 RDBMS로 복잡한 쿼리, 대규모 데이터 처리, 엔터프라이즈·금융·분석 시스템에 강점


# 데이터베이스 인덱스란?

데이터베이스에는 수많은 데이터가 저장되므로 특정 조건(예: 나이=20)인 행을 찾으려면 인덱스가 없을 경우 
데이터베이스는 모든 행을 하나씩 확인(풀스캔)해야 하므로 데이터가 많을수록 매우 느려지므로 인덱스는 이러한 비효율을 해결해주는 기능

원하는 데이터를 빠르게 찾을 수 있도록 "정렬된" 자료구조이며 단순 배열이나 리스트로 정렬할 수도 있지만 트리(Tree) 구조를 사용하고
B-트리나 B+트리 구조가 많이 쓰임.

- 인덱스의 장점
1. 검색 속도 대폭 향상: 대량의 데이터 중 원하는 값을 빠르게 찾을 수 있음
2. 범위 검색 효율적: B+트리 구조 덕분에 "나이 20~30"처럼 범위 조건도 빠르게 처리할 수 있음

- 인덱스의 단점과 주의점
1. 추가 저장공간 필요: 인덱스는 컬럼을 복사해 정렬해두는 개념이니 그만큼 데이터베이스 용량이 더 필요
2. 쓰기 작업의 부하: 데이터 삽입, 수정, 삭제 시 인덱스도 함께 갱신해야 하므로 쓰기 작업이 잦은 컬럼에는 남발하지 않는 것이 좋음
3. 프라이머리 키: 기본키(Primary Key)로 지정된 컬럼은 자동으로 정렬되어 있으므로 별도의 인덱스 생성이 필요 없음


# API란?

Application Programming Interface의 약자로 한 프로그램에서 다른 프로그램으로 데이터를 주고 받기 위한 방법

API는 식당의 메뉴판에 비유할 수 있다. 식당에서 손님은 메뉴판에 적힌 음식만 주문할 수 있고 주방장은 메뉴판에 없는 특별 주문을 받지 않는다.

따라서 API는 프로그램에 “이런 기능(음식)만 요청할 수 있다”는 규칙(메뉴판)을 제공하고
사용자는 메뉴판(API)에 적힌 대로만 요청해야 하며 프로그램(서버)은 그에 맞는 결과를 리턴해줌.

API는 사양, 원칙이지 무언가를 프로그래밍한 구현체가 아님.

## API의 종류
- 공개 API(Public API) : 누구나 사용할 수 있도록 공개된 API
- 비공개 API(Private API) : 내부 시스템이나 특정 파트너만 사용할 수 있도록 제한된 API
- 운영체제 API (OS API) : 윈도우, 안드로이드 등에서 제공하는 시스템 기능 호출용 API

# RESTful API란?
- REST API(Representational State Transfer API)는 오늘날 웹 개발에서 가장 널리 쓰이는 API 설계 방식
- “어떻게 요청하고, 어떻게 응답할지”에 대한 구체적 형식을 정의

## REST API의 기본 원칙
- 자원(Resource) 중심: URI(주소)는 “무엇에 대한 요청인지”만 표현하고, “무엇을 할지”는 HTTP 메소드로 구분

- HTTP 메소드 활용:
1. GET: 데이터 조회(예: 책 목록, 특정 책 정보)
2. POST: 데이터 생성(예: 새 책 등록)
3. PUT: 전체 데이터 수정(예: 책 정보 전체 변경)
4. PATCH: 일부 데이터 수정(예: 책 상태만 변경)
5. DELETE: 데이터 삭제(예: 책 삭제)

## REST API의 주요 특징

1. 명확하고 직관적이며 요청만 봐도 어떤 작업인지 한눈에 알 수 있음.
2. 상태 코드 사용
- 200번대: 성공
- 400번대: 클라이언트 오류(잘못된 요청 등)
- 500번대: 서버 오류

3. Stateless(무상태성): 서버는 클라이언트의 상태를 기억하지 않으며 각 요청에 필요한 모든 정보를 포함해야 함.
4. 캐싱 가능: 동일 요청에 대한 응답을 클라이언트/서버가 저장해두고 재사용할 수 있음.
5. 계층적 구조: 리소스 간 상하위 관계를 URI로 표현 가능(예: /books/1/reviews).

